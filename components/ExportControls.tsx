import React from 'react';
import { Reading, UserProfile, BPCategory } from '../types';
import saveAs from 'file-saver';
import { Document, Packer, Paragraph, Table, TableRow, TableCell, WidthType, HeadingLevel, AlignmentType, ShadingType, TextRun, BorderStyle, PageOrientation, VerticalAlign } from 'docx';
import * as XLSX from 'xlsx';
import { ExcelIcon, WordIcon, EmailIcon, DeleteAllIcon } from './Icons';
import { getBPCategory } from '../utils/bpUtils';
import { BP_CATEGORIES_INFO } from '../constants';

interface ExportControlsProps {
    readings: Reading[];
    deleteAllReadings: () => void;
    userProfile: UserProfile;
}

const ExportControls: React.FC<ExportControlsProps> = ({ readings, deleteAllReadings, userProfile }) => {

    const getContrastColor = (hex: string): 'FFFFFF' | '000000' => {
        if (!hex) return '000000';
        try {
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
            return (yiq >= 128) ? '000000' : 'FFFFFF';
        } catch (e) {
            return '000000';
        }
    };

    const calculateComprehensiveStats = () => {
        if (readings.length === 0) return null;

        const totals = readings.reduce((acc, r) => {
            acc.systolic += r.systolic;
            acc.diastolic += r.diastolic;
            acc.pulse += r.pulse;
            return acc;
        }, { systolic: 0, diastolic: 0, pulse: 0 });

        const categoryCounts = readings.reduce((acc, r) => {
            const category = getBPCategory(r.systolic, r.diastolic);
            acc[category] = (acc[category] || 0) + 1;
            return acc;
        }, {} as Record<BPCategory, number>);

        return {
            totalReadings: readings.length,
            morningReadings: readings.filter(r => r.timeOfDay === 'Morning').length,
            eveningReadings: readings.filter(r => r.timeOfDay === 'Evening').length,
            avgSystolic: Math.round(totals.systolic / readings.length),
            avgDiastolic: Math.round(totals.diastolic / readings.length),
            avgPulse: Math.round(totals.pulse / readings.length),
            categoryCounts,
        };
    };

    const exportToExcel = () => {
        const stats = calculateComprehensiveStats();
        const now = new Date();
        const reportDate = `Report Generated by OK Blood Diary on ${now.toLocaleDateString()} at ${now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
        
        const aoaHeader = [
            ["Blood Pressure Diary Report"],
            [reportDate],
            [],
            ["PATIENT INFORMATION"],
            ["Full Name:", userProfile.fullName || 'N/A'],
            ["Date of Birth:", userProfile.dateOfBirth ? new Date(userProfile.dateOfBirth).toLocaleDateString(undefined, { timeZone: 'UTC' }) : 'N/A'],
            [],
            ["SUMMARY ANALYSIS"],
            ["Total Readings:", stats?.totalReadings || 0, null, "Average Systolic:", `${stats?.avgSystolic || 0} mmHg`],
            ["Morning/Evening:", `${stats?.morningReadings || 0} / ${stats?.eveningReadings || 0}`, null, "Average Diastolic:", `${stats?.avgDiastolic || 0} mmHg`],
            ["Category Breakdown:", Object.entries(stats?.categoryCounts || {}).map(([cat, count]) => `${cat}: ${count}`).join(', '), null, "Average Pulse:", `${stats?.avgPulse || 0} bpm`],
            [],
            ["DETAILED READINGS"],
            ["Date", "Time", "Systolic", "Diastolic", "Pulse", "BP Category", "Notes"]
        ];
    
        const worksheet = XLSX.utils.aoa_to_sheet(aoaHeader);
    
        const dataRows = readings.map(r => {
            const category = getBPCategory(r.systolic, r.diastolic);
            const formattedDate = new Date(r.date).toLocaleDateString(undefined, { timeZone: 'UTC' });
            return [formattedDate, `${r.timeOfDay} #${r.readingNumber}`, r.systolic, r.diastolic, r.pulse, category, r.notes || ''];
        });
    
        const dataStartRow = 14;
        XLSX.utils.sheet_add_json(worksheet, dataRows, { origin: `A${dataStartRow}`, skipHeader: true });

        // --- STYLING (to match Word export) ---
        const titleStyle = { font: { sz: 24, bold: true }, alignment: { horizontal: 'center', vertical: 'center' } };
        const subtitleStyle = { font: { sz: 11, italic: true }, alignment: { horizontal: 'center', vertical: 'center' } };
        const sectionHeaderStyle = {
            font: { sz: 14, bold: true, color: { rgb: "FFFFFF" } },
            fill: { fgColor: { rgb: "005A9E" } },
            alignment: { horizontal: 'center', vertical: 'center' }
        };
        const labelStyle = { font: { bold: true } };
        const borderStyle = { style: 'thin', color: { rgb: '000000' } };
        const borders = { top: borderStyle, bottom: borderStyle, left: borderStyle, right: borderStyle };

        worksheet['A1'].s = titleStyle;
        worksheet['A2'].s = subtitleStyle;
        worksheet['A4'].s = sectionHeaderStyle;
        worksheet['A8'].s = sectionHeaderStyle;
        worksheet['A13'].s = sectionHeaderStyle;

        worksheet['A5'].s = labelStyle;
        worksheet['A6'].s = labelStyle;
        worksheet['A9'].s = labelStyle;
        worksheet['D9'].s = labelStyle;
        worksheet['A10'].s = labelStyle;
        worksheet['D10'].s = labelStyle;
        worksheet['A11'].s = labelStyle;
        worksheet['D11'].s = labelStyle;
        
        if (worksheet['B11']) {
            worksheet['B11'].s = { alignment: { wrapText: true, vertical: 'top' } };
        }

        const tableHeaderStyle = { 
            font: { sz: 12, bold: true, color: { rgb: "000000" } }, 
            fill: { fgColor: { rgb: "DDEBF7" } },
            alignment: { horizontal: 'center', vertical: 'center' },
            border: borders
        };
        
        const headerCols = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
        headerCols.forEach(col => {
            const cellRef = `${col}${dataStartRow-1}`;
            if (worksheet[cellRef]) worksheet[cellRef].s = tableHeaderStyle;
        });
        
        const alternateRowFill = { fgColor: { rgb: "F2F2F2" } };

        dataRows.forEach((row, rowIndex) => {
            const rowNum = dataStartRow + rowIndex;
            const category = row[5] as BPCategory;
            const categoryInfo = BP_CATEGORIES_INFO[category];
            const isAlternateRow = rowIndex % 2 !== 0;

            for (let i = 0; i < row.length; i++) {
                const colLetter = String.fromCharCode(65 + i);
                const cellRef = `${colLetter}${rowNum}`;
                if (!worksheet[cellRef]) {
                     XLSX.utils.sheet_add_aoa(worksheet, [[row[i]]], { origin: cellRef });
                }
                const baseStyle: any = { 
                    alignment: { horizontal: 'center', vertical: 'center' },
                    border: borders,
                    fill: isAlternateRow ? alternateRowFill : undefined
                };
                 if (i === 6) { // Notes column
                    baseStyle.alignment = { horizontal: 'left', vertical: 'center', wrapText: true };
                }
                worksheet[cellRef].s = baseStyle;
            }

            if (categoryInfo) {
                const fontColor = getContrastColor(categoryInfo.hexColor);
                const catCellStyle: any = { 
                    fill: { fgColor: { rgb: categoryInfo.hexColor } }, 
                    font: { color: { rgb: fontColor }, bold: true },
                    alignment: { horizontal: 'center', vertical: 'center' },
                    border: borders,
                };
                if (isAlternateRow) {
                    catCellStyle.fill = { fgColor: { rgb: categoryInfo.hexColor } }; // Override zebra stripe
                }
                const categoryCellRef = `F${rowNum}`;
                if (worksheet[categoryCellRef]) worksheet[categoryCellRef].s = catCellStyle;
            }
        });

        // --- LAYOUT AND SIZING ---
        worksheet['!pageSetup'] = { orientation: 'landscape' };

        worksheet['!merges'] = [
            { s: { r: 0, c: 0 }, e: { r: 0, c: 6 } }, { s: { r: 1, c: 0 }, e: { r: 1, c: 6 } },
            { s: { r: 3, c: 0 }, e: { r: 3, c: 6 } }, { s: { r: 7, c: 0 }, e: { r: 7, c: 6 } },
            { s: { r: 12, c: 0 }, e: { r: 12, c: 6 } },
            { s: { r: 10, c: 1 }, e: { r: 10, c: 2 } }, // Merge category breakdown
        ];
        
        worksheet['!cols'] = [
            { wch: 15 }, { wch: 20 }, { wch: 12 }, { wch: 12 }, 
            { wch: 12 }, { wch: 25 }, { wch: 50 }
        ];

        const rows: XLSX.RowInfo[] = new Array(dataStartRow + dataRows.length).fill(null);
        rows[0] = { hpt: 30 }; rows[3] = { hpt: 25 }; rows[7] = { hpt: 25 };
        rows[10] = { hpt: 40 }; 
        rows[12] = { hpt: 25 }; rows[13] = { hpt: 22 };
        for (let i = 0; i < dataRows.length; i++) { 
             const noteLength = (dataRows[i][6] as string)?.length || 0;
             const baseHeight = 20;
             const noteHeight = Math.ceil(noteLength / 50) * 15;
             rows[dataStartRow -1 + i] = { hpt: Math.max(baseHeight, noteHeight) };
        }
        worksheet['!rows'] = rows;

        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, "BP Report");
        const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        const data = new Blob([excelBuffer], { type: "application/octet-stream" });
        saveAs(data, `BloodPressureReport_${userProfile.fullName.replace(/\s/g, '_')}.xlsx`);
    };

    const exportToWord = () => {
        const stats = calculateComprehensiveStats();
        const now = new Date();
        
        const title = new Paragraph({ text: "Blood Pressure Diary Report", heading: HeadingLevel.HEADING_1, alignment: AlignmentType.CENTER });
        const reportDatePara = new Paragraph({ text: `Report Generated by OK Blood Diary on ${now.toLocaleDateString()} at ${now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`, alignment: AlignmentType.CENTER });

        const sectionHeaderProps = {
            alignment: AlignmentType.CENTER,
            shading: { type: ShadingType.SOLID, color: "005A9E" },
            spacing: { before: 300, after: 100 },
        };

        const createSectionHeader = (text: string) => new Paragraph({
            children: [new TextRun({ text, bold: true, size: 28, color: "FFFFFF" })],
            ...sectionHeaderProps
        });
        
        const patientHeader = createSectionHeader("PATIENT INFORMATION");
        const patientInfo = new Table({
            width: { size: 100, type: WidthType.PERCENTAGE },
            rows: [
                new TableRow({ children: [
                    new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: "Full Name:", bold: true })] })], verticalAlign: VerticalAlign.CENTER }),
                    new TableCell({ children: [new Paragraph(userProfile.fullName || 'N/A')] }),
                ]}),
                new TableRow({ children: [
                    new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: "Date of Birth:", bold: true })] })], verticalAlign: VerticalAlign.CENTER }),
                    new TableCell({ children: [new Paragraph(userProfile.dateOfBirth ? new Date(userProfile.dateOfBirth).toLocaleDateString(undefined, { timeZone: 'UTC' }) : 'N/A')] }),
                ]}),
            ],
            borders: { insideHorizontal: { style: BorderStyle.NONE }, insideVertical: { style: BorderStyle.NONE }, top: { style: BorderStyle.NONE }, bottom: { style: BorderStyle.NONE }, left: { style: BorderStyle.NONE }, right: { style: BorderStyle.NONE } },
        });

        const summaryHeader = createSectionHeader("SUMMARY ANALYSIS");
        const summaryTable = new Table({
             width: { size: 100, type: WidthType.PERCENTAGE },
             rows: [
                new TableRow({ children: [
                    new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: "Total Readings:", bold: true })] })] }), new TableCell({ children: [new Paragraph(String(stats?.totalReadings || 0))] }),
                    new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: "Average Systolic:", bold: true })] })] }), new TableCell({ children: [new Paragraph(`${stats?.avgSystolic || 0} mmHg`)] }),
                ]}),
                 new TableRow({ children: [
                    new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: "Morning/Evening:", bold: true })] })] }), new TableCell({ children: [new Paragraph(`${stats?.morningReadings || 0} / ${stats?.eveningReadings || 0}`)] }),
                    new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: "Average Diastolic:", bold: true })] })] }), new TableCell({ children: [new Paragraph(`${stats?.avgDiastolic || 0} mmHg`)] }),
                ]}),
                new TableRow({ children: [
                    new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: "Category Breakdown:", bold: true })] })] }), 
                    new TableCell({ children: [new Paragraph(Object.entries(stats?.categoryCounts || {}).map(([cat, count]) => `${cat}: ${count}`).join(', '))] }),
                    new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: "Average Pulse:", bold: true })] })] }), new TableCell({ children: [new Paragraph(`${stats?.avgPulse || 0} bpm`)] }),
                ]}),
            ],
             borders: { insideHorizontal: { style: BorderStyle.NONE }, insideVertical: { style: BorderStyle.NONE }, top: { style: BorderStyle.NONE }, bottom: { style: BorderStyle.NONE }, left: { style: BorderStyle.NONE }, right: { style: BorderStyle.NONE } },
        });

        const readingsHeader = createSectionHeader("DETAILED READINGS");
        const headerRow = new TableRow({
            children: ["Date", "Time", "Systolic", "Diastolic", "Pulse", "BP Category", "Notes"].map(text => new TableCell({
                children: [new Paragraph({ alignment: AlignmentType.CENTER, children: [new TextRun({ text, bold: true })] })],
                shading: { type: ShadingType.SOLID, color: "DDEBF7" },
                verticalAlign: VerticalAlign.CENTER,
            })),
            tableHeader: true,
        });

        const dataRowsWord = readings.map(r => {
            const category = getBPCategory(r.systolic, r.diastolic);
            const categoryInfo = BP_CATEGORIES_INFO[category];
            const formattedDate = new Date(r.date).toLocaleDateString(undefined, { timeZone: 'UTC' });
            const fontColor = getContrastColor(categoryInfo.hexColor);

            return new TableRow({
                children: [
                    new TableCell({ children: [new Paragraph(formattedDate)], verticalAlign: VerticalAlign.CENTER }),
                    new TableCell({ children: [new Paragraph(`${r.timeOfDay} #${r.readingNumber}`)], verticalAlign: VerticalAlign.CENTER }),
                    new TableCell({ children: [new Paragraph({ text: String(r.systolic), alignment: AlignmentType.CENTER })], verticalAlign: VerticalAlign.CENTER }),
                    new TableCell({ children: [new Paragraph({ text: String(r.diastolic), alignment: AlignmentType.CENTER })], verticalAlign: VerticalAlign.CENTER }),
                    new TableCell({ children: [new Paragraph({ text: String(r.pulse), alignment: AlignmentType.CENTER })], verticalAlign: VerticalAlign.CENTER }),
                    new TableCell({
                        children: [new Paragraph({ 
                            children: [ new TextRun({ text: category, color: fontColor, bold: true })],
                            alignment: AlignmentType.CENTER 
                        })],
                        shading: { type: ShadingType.SOLID, color: categoryInfo.hexColor },
                        verticalAlign: VerticalAlign.CENTER,
                    }),
                    new TableCell({ children: [new Paragraph(r.notes || '')], verticalAlign: VerticalAlign.CENTER }),
                ],
            });
        });

        const readingsTable = new Table({
            width: { size: 100, type: WidthType.PERCENTAGE },
            rows: [headerRow, ...dataRowsWord],
            margins: { top: 100, bottom: 100, left: 100, right: 100 },
             borders: {
                top: { style: BorderStyle.SINGLE, size: 1, color: "000000" }, bottom: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
                left: { style: BorderStyle.SINGLE, size: 1, color: "000000" }, right: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
                insideHorizontal: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" }, insideVertical: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
            },
        });
        
        const doc = new Document({
            sections: [{
                properties: {
                    page: {
                        margin: { top: 720, right: 720, bottom: 720, left: 720 },
                        size: { orientation: PageOrientation.LANDSCAPE }
                    }
                },
                children: [
                    title, reportDatePara, patientHeader, patientInfo, 
                    summaryHeader, summaryTable, readingsHeader, readingsTable
                ]
            }]
        });

        Packer.toBlob(doc).then(blob => {
            saveAs(blob, `BloodPressureReport_${userProfile.fullName.replace(/\s/g, '_')}.docx`);
        });
    };

    const generateTextReport = (): string => {
        const stats = calculateComprehensiveStats();
        const now = new Date();
    
        let report = `Blood Pressure Diary Report\n`;
        report += `Report Generated by OK Blood Diary on ${now.toLocaleDateString()} at ${now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}\n\n`;
        
        report += `--- PATIENT INFORMATION ---\n`;
        report += `Full Name: ${userProfile.fullName || 'N/A'}\n`;
        report += `Date of Birth: ${userProfile.dateOfBirth ? new Date(userProfile.dateOfBirth).toLocaleDateString(undefined, { timeZone: 'UTC' }) : 'N/A'}\n\n`;
    
        if (stats) {
            report += `--- SUMMARY ANALYSIS ---\n`;
            report += `Total Readings: ${stats.totalReadings}\n`;
            report += `Morning/Evening: ${stats.morningReadings} / ${stats.eveningReadings}\n`;
            report += `Average: ${stats.avgSystolic}/${stats.avgDiastolic} mmHg, Pulse: ${stats.avgPulse} bpm\n`;
            report += `Category Breakdown: ${Object.entries(stats.categoryCounts).map(([cat, count]) => `${cat}: ${count}`).join(', ')}\n\n`;
        }
    
        report += `--- DETAILED READINGS ---\n`;
        report += `Date, Time, Systolic, Diastolic, Pulse, Category, Notes\n`;
        readings.forEach(r => {
            const category = getBPCategory(r.systolic, r.diastolic);
            const formattedDate = new Date(r.date).toLocaleDateString(undefined, { timeZone: 'UTC' });
            report += `${formattedDate}, ${r.timeOfDay} #${r.readingNumber}, ${r.systolic}, ${r.diastolic}, ${r.pulse}, ${category}, "${r.notes || ''}"\n`;
        });
    
        report += `\nThis report was generated by the OK Blood Diary app.`;
    
        return report;
    };

    const emailReport = () => {
        const subject = `Blood Pressure Report for ${userProfile.fullName}`;
        const body = generateTextReport();

        if (encodeURIComponent(body).length > 2000) {
            alert("This report is too long to be embedded in an email. Please use the Word or Excel export and attach the file instead.");
            return;
        }

        window.location.href = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
    };

    return (
        <div className="bg-white dark:bg-slate-800 p-4 sm:p-6 rounded-lg shadow">
            <h3 className="text-xl font-semibold mb-4 text-slate-800 dark:text-white">Export & Manage</h3>
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                <button onClick={exportToWord} disabled={readings.length === 0} className="flex items-center justify-center w-full px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 disabled:bg-slate-400 disabled:cursor-not-allowed">
                    <WordIcon className="h-5 w-5 mr-2" /> Export to Word
                </button>
                <button onClick={exportToExcel} disabled={readings.length === 0} className="flex items-center justify-center w-full px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-green-600 hover:bg-green-700 disabled:bg-slate-400 disabled:cursor-not-allowed">
                    <ExcelIcon className="h-5 w-5 mr-2" /> Export to Excel
                </button>
                 <button onClick={emailReport} disabled={readings.length === 0} className="flex items-center justify-center w-full px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-gray-500 hover:bg-gray-600 disabled:bg-slate-400 disabled:cursor-not-allowed">
                    <EmailIcon className="h-5 w-5 mr-2" /> Email Report
                </button>
                <button onClick={deleteAllReadings} disabled={readings.length === 0} className="flex items-center justify-center w-full px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-red-600 hover:bg-red-700 disabled:bg-slate-400 disabled:cursor-not-allowed">
                    <DeleteAllIcon className="h-5 w-5 mr-2" /> Delete All Data
                </button>
            </div>
        </div>
    );
};

export default ExportControls;